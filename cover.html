
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>animus: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/divy-sh/animus/cmd/animus/handler.go (0.0%)</option>
				
				<option value="file1">github.com/divy-sh/animus/internal/command/genericcmd/copyvalcmd.go (100.0%)</option>
				
				<option value="file2">github.com/divy-sh/animus/internal/command/genericcmd/delcmd.go (100.0%)</option>
				
				<option value="file3">github.com/divy-sh/animus/internal/command/genericcmd/existscmd.go (100.0%)</option>
				
				<option value="file4">github.com/divy-sh/animus/internal/command/genericcmd/expirecmd.go (100.0%)</option>
				
				<option value="file5">github.com/divy-sh/animus/internal/command/genericcmd/keyscmd.go (100.0%)</option>
				
				<option value="file6">github.com/divy-sh/animus/internal/command/handler.go (100.0%)</option>
				
				<option value="file7">github.com/divy-sh/animus/internal/command/hashcmd/hgetcmd.go (100.0%)</option>
				
				<option value="file8">github.com/divy-sh/animus/internal/command/hashcmd/hsetcmd.go (100.0%)</option>
				
				<option value="file9">github.com/divy-sh/animus/internal/command/helpcmd.go (100.0%)</option>
				
				<option value="file10">github.com/divy-sh/animus/internal/command/listcmd/rpopcmd.go (100.0%)</option>
				
				<option value="file11">github.com/divy-sh/animus/internal/command/listcmd/rpushcmd.go (100.0%)</option>
				
				<option value="file12">github.com/divy-sh/animus/internal/command/pingcmd/pingcmd.go (100.0%)</option>
				
				<option value="file13">github.com/divy-sh/animus/internal/command/stringcmd/appendcmd.go (100.0%)</option>
				
				<option value="file14">github.com/divy-sh/animus/internal/command/stringcmd/decrbycmd.go (100.0%)</option>
				
				<option value="file15">github.com/divy-sh/animus/internal/command/stringcmd/decrcmd.go (100.0%)</option>
				
				<option value="file16">github.com/divy-sh/animus/internal/command/stringcmd/getcmd.go (100.0%)</option>
				
				<option value="file17">github.com/divy-sh/animus/internal/command/stringcmd/getdelcmd.go (100.0%)</option>
				
				<option value="file18">github.com/divy-sh/animus/internal/command/stringcmd/getexcmd.go (100.0%)</option>
				
				<option value="file19">github.com/divy-sh/animus/internal/command/stringcmd/getrangecmd.go (100.0%)</option>
				
				<option value="file20">github.com/divy-sh/animus/internal/command/stringcmd/getsetcmd.go (100.0%)</option>
				
				<option value="file21">github.com/divy-sh/animus/internal/command/stringcmd/incrbycmd.go (100.0%)</option>
				
				<option value="file22">github.com/divy-sh/animus/internal/command/stringcmd/incrbyfloatcmd.go (100.0%)</option>
				
				<option value="file23">github.com/divy-sh/animus/internal/command/stringcmd/incrcmd.go (100.0%)</option>
				
				<option value="file24">github.com/divy-sh/animus/internal/command/stringcmd/lcscmd.go (100.0%)</option>
				
				<option value="file25">github.com/divy-sh/animus/internal/command/stringcmd/mgetcmd.go (100.0%)</option>
				
				<option value="file26">github.com/divy-sh/animus/internal/command/stringcmd/msetcmd.go (100.0%)</option>
				
				<option value="file27">github.com/divy-sh/animus/internal/command/stringcmd/setcmd.go (100.0%)</option>
				
				<option value="file28">github.com/divy-sh/animus/internal/resp/reader.go (82.9%)</option>
				
				<option value="file29">github.com/divy-sh/animus/internal/resp/writer.go (97.8%)</option>
				
				<option value="file30">github.com/divy-sh/animus/internal/store/store.go (87.8%)</option>
				
				<option value="file31">github.com/divy-sh/animus/internal/store/storeCleaner.go (91.4%)</option>
				
				<option value="file32">github.com/divy-sh/animus/internal/types/generics/generics.go (100.0%)</option>
				
				<option value="file33">github.com/divy-sh/animus/internal/types/hashes/hashes.go (100.0%)</option>
				
				<option value="file34">github.com/divy-sh/animus/internal/types/lists/lists.go (100.0%)</option>
				
				<option value="file35">github.com/divy-sh/animus/internal/types/strings/strings.go (100.0%)</option>
				
				<option value="file36">github.com/divy-sh/animus/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package animus

import (
        "log"
        "net"
        "strings"

        "github.com/divy-sh/animus/internal/command"
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
)

func Handle() <span class="cov0" title="0">{
        log.Print("Listening on port :6379")
        // Create a new server
        l, err := net.Listen("tcp", ":6379")
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                return
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                // Listen for connections
                conn, err := l.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        log.Print(err)
                        return
                }</span>
                <span class="cov0" title="0">defer conn.Close()
                go handleRequests(conn)</span>
        }
}

func handleRequests(conn net.Conn) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                reader := resp.NewReader(conn)
                value, err := reader.Read()
                if err != nil </span><span class="cov0" title="0">{
                        log.Print(err)
                        return
                }</span>
                <span class="cov0" title="0">if value.Typ != "array" </span><span class="cov0" title="0">{
                        log.Print("Invalid request, expected array")
                        continue</span>
                }
                <span class="cov0" title="0">if len(value.Array) == 0 </span><span class="cov0" title="0">{
                        log.Print("Invalid request, expected array length &gt; 0")
                        continue</span>
                }
                <span class="cov0" title="0">cmd := strings.ToUpper(value.Array[0].Bulk)
                args := value.Array[1:]
                writer := resp.NewWriter(conn)
                if cmd == "QUIT" </span><span class="cov0" title="0">{
                        writer.Write(resp.Value{Typ: common.STRING_TYPE, Str: "OK"})
                        return
                }</span>
                <span class="cov0" title="0">handler, ok := command.Handlers[cmd]
                if !ok </span><span class="cov0" title="0">{
                        log.Print("Invalid command: ", cmd)
                        writer.Write(resp.Value{Typ: common.STRING_TYPE, Str: ""})
                        continue</span>
                }
                <span class="cov0" title="0">result := handler.Func(args)
                writer.Write(result)</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package genericcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/generics"
)

func CopyVal(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 2 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">val, err := generics.Copy(args[0].Bulk, args[1].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.INTEGER_TYPE, Num: val}</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package genericcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/generics"
)

func Del(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">keys := make([]string, len(args))
        for i := 0; i &lt; len(args); i += 2 </span><span class="cov8" title="1">{
                keys[i] = args[i].Bulk
        }</span>
        <span class="cov8" title="1">generics.Delete(&amp;keys)
        return resp.Value{Typ: common.BULK_TYPE, Bulk: "OK"}</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package genericcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/generics"
)

func Exists(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">keys := make([]string, len(args))
        for i := 0; i &lt; len(args); i += 2 </span><span class="cov8" title="1">{
                keys[i] = args[i].Bulk
        }</span>
        <span class="cov8" title="1">validKeyCount := generics.Exists(&amp;keys)
        return resp.Value{Typ: common.INTEGER_TYPE, Num: validKeyCount}</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package genericcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/generics"
)

func Expire(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) == 2 </span><span class="cov8" title="1">{
                err := generics.Expire(args[0].Bulk, args[1].Bulk, "")
                if err != nil </span><span class="cov8" title="1">{
                        return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
                }</span>
        } else<span class="cov8" title="1"> if len(args) == 3 </span><span class="cov8" title="1">{
                err := generics.Expire(args[0].Bulk, args[1].Bulk, args[2].Bulk)
                if err != nil </span><span class="cov8" title="1">{
                        return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
                }</span>
        } else<span class="cov8" title="1"> {
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.BULK_TYPE, Bulk: "OK"}</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package genericcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/generics"
)

func Keys(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">values, err := generics.Keys(args[0].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
        }</span>
        <span class="cov8" title="1">response := make([]resp.Value, len(*values))
        for i, val := range *values </span><span class="cov8" title="1">{
                response[i] = resp.Value{Typ: common.BULK_TYPE, Bulk: val}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.ARRAY_TYPE, Array: response}</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package command

import (
        "github.com/divy-sh/animus/internal/command/genericcmd"
        "github.com/divy-sh/animus/internal/command/hashcmd"
        "github.com/divy-sh/animus/internal/command/listcmd"
        "github.com/divy-sh/animus/internal/command/pingcmd"
        "github.com/divy-sh/animus/internal/command/stringcmd"
        "github.com/divy-sh/animus/internal/resp"
)

// Command represents a command with an associated function and documentation.
type Command struct {
        Func func([]resp.Value) resp.Value
        Doc  string
}

// Handlers maps command names to their implementations.
var Handlers = map[string]Command{}

// RegisterCommand registers a command function with its documentation.
func RegisterCommand(name string, fn func([]resp.Value) resp.Value, doc string) <span class="cov8" title="1">{
        Handlers[name] = Command{Func: fn, Doc: doc}
}</span>

// Initialize commands with their documentation
func init() <span class="cov8" title="1">{
        // Connection
        RegisterCommand("PING", pingcmd.Ping, `PING [ARGUMENT]
        Returns PONG to test server responsiveness.`)

        // Strings
        RegisterCommand("APPEND", stringcmd.Append, `APPEND [KEY] [VALUE]
        Appends a value to a key and returns the new length of the string.`)
        RegisterCommand("DECR", stringcmd.Decr, `DECR [KEY]
        Decrements the integer value of a key by one.`)
        RegisterCommand("DECRBY", stringcmd.DecrBy, `DECRBY [KEY] [DECREMENT]
        Decrements the integer value of a key by the given amount.`)
        RegisterCommand("GET", stringcmd.Get, `GET [KEY]
        Gets the value of a key.`)
        RegisterCommand("GETDEL", stringcmd.GetDel, `GETDEL [KEY]
        Gets the value of a key and deletes it.`)
        RegisterCommand("GETEX", stringcmd.GetEx, `GETEX [KEY] [EXPIRATION]
        Gets the value of a key and sets an expiration.`)
        RegisterCommand("GETRANGE", stringcmd.GetRange, `GETRANGE [KEY] [START] [END]
        Gets a substring of the string stored at a key.`)
        RegisterCommand("GETSET", stringcmd.GetSet, `GETSET [KEY] [VALUE]
        Gets the previous key value and then sets it to the passed value.`)
        RegisterCommand("INCR", stringcmd.Incr, `INCR [KEY]
        Increments the integer value of a key by one.`)
        RegisterCommand("INCRBY", stringcmd.IncrBy, `INCRBY [KEY] [INCREMENT]
        Increments the integer value of a key by the given amount.`)
        RegisterCommand("INCRBYFLOAT", stringcmd.IncrByFloat, `INCRBYFLOAT [KEY] [INCREMENT]
        Increments the float value of a key by the given amount.`)
        RegisterCommand("LCS", stringcmd.LCS, `LCS [KEY1] [KEY2] LEN
        Finds the Longest Common Subsequence between the value of two keys.
        Send the optional LEN argument to get just the length`)
        RegisterCommand("MGET", stringcmd.MGet, `MGET key [key ...]
        Returns the values for all the keys.
        Returns nil for a non-existing key.`)
        RegisterCommand("MSET", stringcmd.MSet, `MSET key value [key1 value1 ...]
        Sets the values for all the keys value pair.`)
        RegisterCommand("SET", stringcmd.Set, `SET [KEY] [VALUE] [EX SECONDS|PX MILLISECONDS|KEEPTTL]
        Sets the value of a key with optional expiration.`)

        // Hashes
        RegisterCommand("HSET", hashcmd.HSet, `HSET [KEY] [FIELD] [VALUE]
        Sets a field in the hash stored at key to a value.`)
        RegisterCommand("HGET", hashcmd.HGet, `HGET [KEY] [FIELD]
        Gets the value of a field in the hash stored at key.`)

        // Lists
        RegisterCommand("RPOP", listcmd.RPop, `RPOP [KEY] [COUNT]
        Removes and returns the last element(s) of the list stored at key.`)
        RegisterCommand("RPUSH", listcmd.RPush, `RPUSH [KEY] [VALUE] [VALUE ...]
        Inserts one or more elements at the end of the list stored at key.`)

        // Help
        RegisterCommand("HELP", Help, `HELP [COMMAND]
        Shows documentation for available commands.`)

        // Generics
        RegisterCommand("COPY", genericcmd.CopyVal, `COPY [key1] [key2]
        Copies value(s) of key1 into key2.
        If key2 doesn't exist, creates key2 and sets its value.`)
        RegisterCommand("DEL", genericcmd.Del, `DEL key1 [keys...]
        Deletes all the keys passes as argument.
        If a key doesn't exist, it is ignored.`)
        RegisterCommand("EXISTS", genericcmd.Exists, `EXISTS key1 [keys...]
        Returns an integer denoting how many of the passed keys exist in the cache.`)
        RegisterCommand("EXPIRE", genericcmd.Expire, `EXPIRE key seconds [NX XX GT LT]
        Sets a timeout on key. After the timeout, the key gets deleted.
        NX - Only set timeout if the key has no previous expiry.
        XX - Only set timeout if the key has a previous expiry.
        GT - Only set timeout if the new time is greater than the existing expiry.
        LT - Only set timeout if the new time is less than the existing expiry.`)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package hashcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/hashes"
)

func HGet(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 2 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>

        <span class="cov8" title="1">value, err := hashes.HGet(args[0].Bulk, args[1].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.BULK_TYPE, Bulk: value}</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package hashcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/hashes"
)

func HSet(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 3 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>

        <span class="cov8" title="1">hashes.HSet(args[0].Bulk, args[1].Bulk, args[2].Bulk)
        return resp.Value{Typ: common.STRING_TYPE, Str: "OK"}</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package command

import (
        "fmt"
        "strings"

        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
)

func Help(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                var docs []string
                for cmd, handler := range Handlers </span><span class="cov8" title="1">{
                        docs = append(docs, fmt.Sprintf("%s - %s", cmd, handler.Doc))
                }</span>
                <span class="cov8" title="1">return resp.Value{Typ: common.BULK_TYPE, Bulk: strings.Join(docs, "\n")}</span>
        }

        <span class="cov8" title="1">cmd := strings.ToUpper(args[0].Bulk)
        if handler, exists := Handlers[cmd]; exists </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.BULK_TYPE, Bulk: fmt.Sprintf("%s - %s", cmd, handler.Doc)}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.ERROR_TYPE, Str: "Unknown command: " + cmd}</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package listcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/lists"
)

func RPop(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">var values []string
        var err error
        if len(args) == 1 </span><span class="cov8" title="1">{
                values, err = lists.RPop(args[0].Bulk, "1")
        }</span> else<span class="cov8" title="1"> {
                values, err = lists.RPop(args[0].Bulk, args[1].Bulk)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
        }</span>
        <span class="cov8" title="1">respArr := make([]resp.Value, len(values))
        for i, val := range values </span><span class="cov8" title="1">{
                respArr[i] = resp.Value{Typ: common.BULK_TYPE, Bulk: val}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.ARRAY_TYPE, Array: respArr}</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package listcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/lists"
)

func RPush(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">values := make([]string, len(args)-1)
        for i, val := range args[1:] </span><span class="cov8" title="1">{
                values[i] = val.Bulk
        }</span>
        <span class="cov8" title="1">lists.RPush(args[0].Bulk, &amp;values)
        return resp.Value{Typ: common.STRING_TYPE, Str: "OK"}</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package pingcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
)

func Ping(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.STRING_TYPE, Str: "PONG"}
        }</span>

        <span class="cov8" title="1">return resp.Value{Typ: common.STRING_TYPE, Str: args[0].Bulk}</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func Append(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 2 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">strings.Append(args[0].Bulk, args[1].Bulk)
        return resp.Value{Typ: common.STRING_TYPE, Str: "OK"}</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func DecrBy(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 2 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>

        <span class="cov8" title="1">err := strings.DecrBy(args[0].Bulk, args[1].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
        }</span>

        <span class="cov8" title="1">return resp.Value{Typ: common.STRING_TYPE, Str: "OK"}</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func Decr(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">err := strings.Decr(args[0].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.STRING_TYPE, Str: "OK"}</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func Get(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">value, err := strings.Get(args[0].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.BULK_TYPE, Bulk: value}</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func GetDel(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">value, err := strings.GetDel(args[0].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.NULL_TYPE}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.BULK_TYPE, Bulk: value}</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func GetEx(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 2 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">value, err := strings.GetEx(args[0].Bulk, args[1].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.NULL_TYPE}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.BULK_TYPE, Bulk: value}</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func GetRange(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 3 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">value, err := strings.GetRange(args[0].Bulk, args[1].Bulk, args[2].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.NULL_TYPE}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.BULK_TYPE, Bulk: value}</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func GetSet(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 2 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>

        <span class="cov8" title="1">val, err := strings.GetSet(args[0].Bulk, args[1].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.BULK_TYPE, Bulk: val}</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func IncrBy(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 2 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>

        <span class="cov8" title="1">err := strings.IncrBy(args[0].Bulk, args[1].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
        }</span>

        <span class="cov8" title="1">return resp.Value{Typ: common.STRING_TYPE, Str: "OK"}</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func IncrByFloat(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 2 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>

        <span class="cov8" title="1">err := strings.IncrByFloat(args[0].Bulk, args[1].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
        }</span>

        <span class="cov8" title="1">return resp.Value{Typ: common.STRING_TYPE, Str: "OK"}</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func Incr(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">err := strings.Incr(args[0].Bulk)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.STRING_TYPE, Str: "OK"}</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func LCS(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">commands := []string{}
        for _, arg := range args[2:] </span><span class="cov8" title="1">{
                commands = append(commands, arg.Bulk)
        }</span>
        <span class="cov8" title="1">val, err := strings.Lcs(args[0].Bulk, args[1].Bulk, commands)
        if err != nil </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: err.Error()}
        }</span>
        <span class="cov8" title="1">return resp.Value{Typ: common.BULK_TYPE, Bulk: val}</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func MGet(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">keys := []string{}
        for _, arg := range args </span><span class="cov8" title="1">{
                keys = append(keys, arg.Bulk)
        }</span>
        <span class="cov8" title="1">values := strings.MGet(&amp;keys)
        response := make([]resp.Value, len(keys))
        for i, val := range *values </span><span class="cov8" title="1">{
                if val == "" </span><span class="cov8" title="1">{
                        response[i] = resp.Value{Typ: common.NULL_TYPE}
                }</span> else<span class="cov8" title="1"> {
                        response[i] = resp.Value{Typ: common.BULK_TYPE, Bulk: val}
                }</span>
        }
        <span class="cov8" title="1">return resp.Value{Typ: common.ARRAY_TYPE, Array: response}</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func MSet(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) &lt; 2 || len(args)&amp;1 == 1 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>
        <span class="cov8" title="1">kvPairs := map[string]string{}
        for i := 0; i &lt; len(args); i += 2 </span><span class="cov8" title="1">{
                kvPairs[args[i].Bulk] = args[i+1].Bulk
        }</span>
        <span class="cov8" title="1">strings.MSet(&amp;kvPairs)
        return resp.Value{Typ: common.STRING_TYPE, Str: "OK"}</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package stringcmd

import (
        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/resp"
        "github.com/divy-sh/animus/internal/types/strings"
)

func Set(args []resp.Value) resp.Value <span class="cov8" title="1">{
        if len(args) != 2 </span><span class="cov8" title="1">{
                return resp.Value{Typ: common.ERROR_TYPE, Str: common.ERR_WRONG_ARGUMENT_COUNT}
        }</span>

        <span class="cov8" title="1">strings.Set(args[0].Bulk, args[1].Bulk)
        return resp.Value{Typ: common.STRING_TYPE, Str: "OK"}</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package resp

import (
        "bufio"
        "io"
        "log"
        "strconv"

        "github.com/divy-sh/animus/internal/common"
)

type Reader struct {
        reader *bufio.Reader
}

func NewReader(rd io.Reader) *Reader <span class="cov8" title="1">{
        return &amp;Reader{reader: bufio.NewReader(rd)}
}</span>

func (r *Reader) Read() (Value, error) <span class="cov8" title="1">{
        valEssentia, err := r.reader.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return Value{}, err
        }</span>
        <span class="cov8" title="1">switch valEssentia </span>{
        case ARRAY:<span class="cov8" title="1">
                return r.readArray()</span>
        case BULK:<span class="cov8" title="1">
                return r.readBulk()</span>
        default:<span class="cov8" title="1">
                log.Printf("Unknown type: %v", valEssentia)
                return Value{}, nil</span>
        }
}

func (r *Reader) readArray() (Value, error) <span class="cov8" title="1">{
        len, err := r.readInt()
        if err != nil </span><span class="cov0" title="0">{
                return Value{}, err
        }</span>
        <span class="cov8" title="1">v := Value{
                Typ:   "array",
                Array: make([]Value, len),
        }
        for i := 0; i &lt; len; i++ </span><span class="cov8" title="1">{
                val, err := r.Read()
                if err != nil </span><span class="cov0" title="0">{
                        return v, err
                }</span>
                <span class="cov8" title="1">v.Array[i] = val</span>
        }
        <span class="cov8" title="1">return v, nil</span>
}

func (r *Reader) readBulk() (Value, error) <span class="cov8" title="1">{
        len, err := r.readInt()
        if err != nil </span><span class="cov0" title="0">{
                return Value{}, err
        }</span>
        <span class="cov8" title="1">bulk := make([]byte, len)
        r.reader.Read(bulk)
        r.readLine()
        return Value{
                Typ:  common.BULK_TYPE,
                Bulk: string(bulk),
        }, nil</span>
}

func (r *Reader) readInt() (val int, err error) <span class="cov8" title="1">{
        line, _, err := r.readLine()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">i64, err := strconv.ParseInt(string(line), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return int(i64), nil</span>
}

func (r *Reader) readLine() (line []byte, n int, err error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                b, err := r.reader.ReadByte()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov8" title="1">line = append(line, b)
                if len(line) &gt; 1 &amp;&amp; line[len(line)-1] == '\n' &amp;&amp; line[len(line)-2] == '\r' </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return line[:len(line)-2], len(line), nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package resp

import (
        "io"
        "strconv"

        "github.com/divy-sh/animus/internal/common"
)

type Writer struct {
        writer io.Writer
}

func NewWriter(w io.Writer) *Writer <span class="cov8" title="1">{
        return &amp;Writer{writer: w}
}</span>

func (v Value) Marshal() []byte <span class="cov8" title="1">{
        switch v.Typ </span>{
        case common.ARRAY_TYPE:<span class="cov8" title="1">
                return v.marshalArray()</span>
        case common.BULK_TYPE:<span class="cov8" title="1">
                return v.marshalBulk()</span>
        case common.INTEGER_TYPE:<span class="cov8" title="1">
                return v.marshalInt()</span>
        case common.STRING_TYPE:<span class="cov8" title="1">
                return v.marshalString()</span>
        case common.NULL_TYPE:<span class="cov8" title="1">
                return v.marshallNull()</span>
        case common.ERROR_TYPE:<span class="cov8" title="1">
                return v.marshallError()</span>
        default:<span class="cov8" title="1">
                return []byte{}</span>
        }
}

func (v Value) marshalInt() []byte <span class="cov8" title="1">{
        var bytes []byte
        bytes = append(bytes, INTEGER)
        bytes = append(bytes, byte(v.Num))
        bytes = append(bytes, '\r', '\n')

        return bytes
}</span>

func (v Value) marshalString() []byte <span class="cov8" title="1">{
        var bytes []byte
        bytes = append(bytes, STRING)
        bytes = append(bytes, v.Str...)
        bytes = append(bytes, '\r', '\n')

        return bytes
}</span>

func (v Value) marshalBulk() []byte <span class="cov8" title="1">{
        var bytes []byte
        bytes = append(bytes, BULK)
        bytes = append(bytes, strconv.Itoa(len(v.Bulk))...)
        bytes = append(bytes, '\r', '\n')
        bytes = append(bytes, v.Bulk...)
        bytes = append(bytes, '\r', '\n')

        return bytes
}</span>

func (v Value) marshalArray() []byte <span class="cov8" title="1">{
        len := len(v.Array)
        var bytes []byte
        bytes = append(bytes, ARRAY)
        bytes = append(bytes, strconv.Itoa(len)...)
        bytes = append(bytes, '\r', '\n')

        for i := 0; i &lt; len; i++ </span><span class="cov8" title="1">{
                bytes = append(bytes, v.Array[i].Marshal()...)
        }</span>

        <span class="cov8" title="1">return bytes</span>
}

func (v Value) marshallError() []byte <span class="cov8" title="1">{
        var bytes []byte
        bytes = append(bytes, ERROR)
        bytes = append(bytes, v.Str...)
        bytes = append(bytes, '\r', '\n')

        return bytes
}</span>

func (v Value) marshallNull() []byte <span class="cov8" title="1">{
        return []byte("$-1\r\n")
}</span>

func (w *Writer) Write(v Value) error <span class="cov8" title="1">{
        var bytes = v.Marshal()
        _, err := w.writer.Write(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package store

import (
        "sync"
        "time"

        lru "github.com/hashicorp/golang-lru/v2"
)

type Store struct {
        LRUCache    *lru.Cache[any, any]
        stopCleaner chan struct{}
        mutex       sync.RWMutex
        isRunning   bool
}

type Value struct {
        Val any
        TTL int64
}

var (
        store *Store
)

func init() <span class="cov8" title="1">{
        cache, _ := lru.New[any, any](100000)
        store = &amp;Store{
                LRUCache:    cache,
                stopCleaner: make(chan struct{}),
                isRunning:   false,
        }
        // // Start the cleaner automatically
        StartExpiryCleaner()
}</span>

func Get[K comparable, V any](key K) (V, bool) <span class="cov8" title="1">{
        store.mutex.RLock()
        val, ok := store.LRUCache.Get(key)
        store.mutex.RUnlock()
        if !ok </span><span class="cov8" title="1">{
                var zero V
                return zero, false
        }</span>
        <span class="cov8" title="1">value := val.(*Value)
        if value.TTL &gt; -1 &amp;&amp; value.TTL &lt;= time.Now().Unix() </span><span class="cov8" title="1">{
                Delete(key)
                var zero V
                return zero, false
        }</span>
        <span class="cov8" title="1">return value.Val.(V), true</span>
}

func GetWithTTL[K comparable, V any](key K) (V, int64, bool) <span class="cov8" title="1">{
        store.mutex.RLock()
        val, ok := store.LRUCache.Get(key)
        store.mutex.RUnlock()
        if !ok </span><span class="cov8" title="1">{
                var zero V
                return zero, -1, false
        }</span>
        <span class="cov8" title="1">value := val.(*Value)
        if value.TTL &gt; -1 &amp;&amp; value.TTL &lt;= time.Now().Unix() </span><span class="cov8" title="1">{
                Delete(key)
                var zero V
                return zero, -1, false
        }</span>
        <span class="cov8" title="1">return value.Val.(V), value.TTL, true</span>
}

func Set[K comparable, V any](key K, value V) <span class="cov8" title="1">{
        store.mutex.Lock()
        defer store.mutex.Unlock()
        store.LRUCache.Add(key, &amp;Value{value, -1})
}</span>

func SetWithTTL[K comparable, V any](key K, value V, ttl int64) <span class="cov8" title="1">{
        store.mutex.Lock()
        defer store.mutex.Unlock()
        store.LRUCache.Add(key, &amp;Value{value, ttl + time.Now().Unix()})
}</span>

func Delete[K comparable](key K) <span class="cov8" title="1">{
        store.mutex.Lock()
        defer store.mutex.Unlock()
        store.LRUCache.Remove(key)
}</span>

func GetKeys[K comparable]() *[]K <span class="cov0" title="0">{
        keys := store.LRUCache.Keys()
        kKeys := []K{}
        for _, key := range keys </span><span class="cov0" title="0">{
                kKeys = append(kKeys, key.(K))
        }</span>
        <span class="cov0" title="0">return &amp;kKeys</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package store

import (
        "math/rand"
        "time"
)

func StartExpiryCleaner() <span class="cov8" title="1">{
        store.mutex.Lock()
        defer store.mutex.Unlock()
        if store.isRunning </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">store.isRunning = true
        store.stopCleaner = make(chan struct{})
        go expiryCleanerLoop(store)</span>
}

func StopExpiryCleaner() <span class="cov8" title="1">{
        store.mutex.Lock()
        defer store.mutex.Unlock()
        if !store.isRunning </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">store.isRunning = false
        close(store.stopCleaner)</span>
}

func expiryCleanerLoop(store *Store) <span class="cov8" title="1">{
        ticker := time.NewTicker(100 * time.Millisecond)
        defer ticker.Stop()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        cleanExpiredKeys()</span>
                case &lt;-store.stopCleaner:<span class="cov8" title="1">
                        return</span>
                }
        }
}

func cleanExpiredKeys() <span class="cov8" title="1">{
        const (
                sampleSize    = 20
                targetPercent = 25.0
                maxIterations = 3
        )
        now := time.Now().Unix()
        store.mutex.RLock()
        allKeys := store.LRUCache.Keys()
        store.mutex.RUnlock()
        if len(allKeys) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for iteration := 0; iteration &lt; maxIterations; iteration++ </span><span class="cov8" title="1">{
                keysToCheck := sampleRandomKeys(allKeys, sampleSize)
                if len(keysToCheck) == 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                // Count expired keys and delete them
                <span class="cov8" title="1">expiredCount := 0
                for _, key := range keysToCheck </span><span class="cov8" title="1">{
                        store.mutex.RLock()
                        val, ok := store.LRUCache.Get(key)
                        store.mutex.RUnlock()
                        if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">value := val.(*Value)
                        if value.TTL &gt; -1 &amp;&amp; value.TTL &lt; now </span><span class="cov8" title="1">{
                                expiredCount++
                                store.mutex.Lock()
                                store.LRUCache.Remove(key)
                                store.mutex.Unlock()
                        }</span>
                }
                <span class="cov8" title="1">if len(keysToCheck) == 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">expiryPercentage := float64(expiredCount) / float64(len(keysToCheck)) * 100
                if expiryPercentage &lt; targetPercent </span><span class="cov8" title="1">{
                        return
                }</span>
        }
}

func sampleRandomKeys(keys []any, sampleSize int) []any <span class="cov8" title="1">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if len(keys) &lt;= sampleSize </span><span class="cov8" title="1">{
                return keys
        }</span>
        <span class="cov8" title="1">shuffled := make([]any, len(keys))
        copy(shuffled, keys)
        for i := range shuffled </span><span class="cov8" title="1">{
                j := rand.Intn(i + 1)
                shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
        }</span>
        <span class="cov8" title="1">return shuffled[:sampleSize]</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package generics

import (
        "errors"
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/store"
)

func Copy(source, destination string) (int, error) <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        value, ok := store.Get[any, any](source)
        if !ok </span><span class="cov8" title="1">{
                return 0, errors.New(common.ERR_SOURCE_KEY_NOT_FOUND)
        }</span>
        <span class="cov8" title="1">store.Set(destination, value)
        return 1, nil</span>
}

func Delete(keys *[]string) <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        for _, key := range *keys </span><span class="cov8" title="1">{
                store.Delete(key)
        }</span>
}

func Exists(keys *[]string) int <span class="cov8" title="1">{
        store.GlobalLock.RLock()
        defer store.GlobalLock.RUnlock()
        validKeyCount := 0
        for _, key := range *keys </span><span class="cov8" title="1">{
                _, exists := store.Get[any, any](key)
                if exists </span><span class="cov8" title="1">{
                        validKeyCount++
                }</span>
        }
        <span class="cov8" title="1">return validKeyCount</span>
}

func Expire(key, seconds, flag string) error <span class="cov8" title="1">{
        secs, _ := strconv.ParseInt(seconds, 10, 64)
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        val, ttl, ok := store.GetWithTTL[any, any](key)
        if !ok </span><span class="cov8" title="1">{
                return errors.New(common.ERR_SOURCE_KEY_NOT_FOUND)
        }</span>
        <span class="cov8" title="1">if ttl == -1 &amp;&amp; strings.ToUpper(flag) == common.EXP_XX </span><span class="cov8" title="1">{
                return errors.New(common.ERR_EXPIRY_TYPE)
        }</span>
        <span class="cov8" title="1">if ttl &gt;= 0 &amp;&amp; strings.ToUpper(flag) == common.EXP_NX </span><span class="cov8" title="1">{
                return errors.New(common.ERR_EXPIRY_TYPE)
        }</span>
        <span class="cov8" title="1">if ttl &gt; time.Now().Unix()+secs &amp;&amp; strings.ToUpper(flag) == common.EXP_GT </span><span class="cov8" title="1">{
                return errors.New(common.ERR_EXPIRY_TYPE)
        }</span>
        <span class="cov8" title="1">if ttl &lt; time.Now().Unix()+secs &amp;&amp; strings.ToUpper(flag) == common.EXP_LT </span><span class="cov8" title="1">{
                return errors.New(common.ERR_EXPIRY_TYPE)
        }</span>
        <span class="cov8" title="1">store.SetWithTTL(key, val, secs)
        return nil</span>
}

func Keys(pattern string) (*[]string, error) <span class="cov8" title="1">{
        re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println("Error compiling regex:", err)
                return nil, errors.New(common.ERR_INVALID_REGEX)
        }</span>
        <span class="cov8" title="1">store.GlobalLock.RLock()
        defer store.GlobalLock.RUnlock()
        allKeys := store.GetKeys[string]()
        matchedKeys := []string{}
        for _, key := range *allKeys </span><span class="cov8" title="1">{
                if re.MatchString(key) </span><span class="cov8" title="1">{
                        matchedKeys = append(matchedKeys, key)
                }</span>
        }
        <span class="cov8" title="1">return &amp;matchedKeys, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package hashes

import (
        "errors"

        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/store"
)

func HGet(hash, key string) (string, error) <span class="cov8" title="1">{
        store.GlobalLock.RLock()
        defer store.GlobalLock.RUnlock()
        value, ok := store.Get[string, map[string]string](hash)
        if !ok </span><span class="cov8" title="1">{
                return "", errors.New(common.ERR_HASH_NOT_FOUND)
        }</span>
        <span class="cov8" title="1">if val, ok := value[key]; ok </span><span class="cov8" title="1">{
                return val, nil
        }</span>
        <span class="cov8" title="1">return "", errors.New(common.ERR_HASH_NOT_FOUND)</span>
}

func HSet(hash, key, value string) <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        hashVal, ok := store.Get[string, map[string]string](hash)
        if ok </span><span class="cov8" title="1">{
                hashVal[key] = value
        }</span> else<span class="cov8" title="1"> {
                hashVal = map[string]string{key: value}
        }</span>
        <span class="cov8" title="1">store.Set(hash, hashVal)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package lists

import (
        "errors"
        "strconv"

        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/store"
)

func RPop(key string, count string) ([]string, error) <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        vals, ok := store.Get[string, []string](key)
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.New(common.ERR_LIST_NOT_FOUND)
        }</span>
        <span class="cov8" title="1">cnt, err := strconv.ParseInt(count, 10, 64)
        if err != nil || cnt &lt;= 0 || cnt &gt; int64(len(vals)) </span><span class="cov8" title="1">{
                return nil, errors.New("ERR invalid count")
        }</span>
        <span class="cov8" title="1">store.Set(key, vals[len(vals)-int(cnt):])
        return vals[len(vals)-int(cnt):], nil</span>
}

func RPush(key string, values *[]string) <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        vals, ok := store.Get[string, []string](key)
        if !ok </span><span class="cov8" title="1">{
                vals = *values
        }</span> else<span class="cov8" title="1"> {
                vals = append(vals, *values...)
        }</span>
        <span class="cov8" title="1">store.Set(key, vals)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package strings

import (
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/divy-sh/animus/internal/common"
        "github.com/divy-sh/animus/internal/store"
)

// public functions
func Append(key, value string) <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        val, ok := store.Get[string, string](key)
        if !ok </span><span class="cov8" title="1">{
                store.Set(key, value)
                return
        }</span>
        <span class="cov8" title="1">store.Set(key, val+value)</span>
}

func Decr(key string) error <span class="cov8" title="1">{
        return DecrBy(key, "1")
}</span>

func DecrBy(key, value string) error <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        decrVal, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("ERR invalid decrement value")
        }</span>
        <span class="cov8" title="1">val, ok := store.Get[string, string](key)
        if !ok </span><span class="cov8" title="1">{
                store.Set(key, fmt.Sprint(-decrVal))
                return nil
        }</span>
        <span class="cov8" title="1">intVal, err := strconv.ParseInt(val, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("ERR value is not an integer or out of range")
        }</span>
        <span class="cov8" title="1">store.Set(key, fmt.Sprint(intVal-decrVal))
        return nil</span>
}

func Get(key string) (string, error) <span class="cov8" title="1">{
        store.GlobalLock.RLock()
        defer store.GlobalLock.RUnlock()
        val, ok := store.Get[string, string](key)
        if !ok </span><span class="cov8" title="1">{
                return "", errors.New(common.ERR_STRING_NOT_FOUND)
        }</span>
        <span class="cov8" title="1">return val, nil</span>
}

func GetDel(key string) (string, error) <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        val, ok := store.Get[string, string](key)
        if !ok </span><span class="cov8" title="1">{
                return "", errors.New(common.ERR_STRING_NOT_FOUND)
        }</span>
        <span class="cov8" title="1">store.Delete(key)
        return val, nil</span>
}

func GetEx(key, exp string) (string, error) <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        val, ok := store.Get[string, string](key)
        if !ok </span><span class="cov8" title="1">{
                return "", errors.New(common.ERR_STRING_NOT_FOUND)
        }</span>
        <span class="cov8" title="1">expSeconds, err := strconv.ParseInt(exp, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.New("ERR invalid expire time")
        }</span>
        <span class="cov8" title="1">store.SetWithTTL(key, val, expSeconds)
        return val, nil</span>
}

func GetRange(key, start, end string) (string, error) <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        val, ok := store.Get[string, string](key)
        if !ok </span><span class="cov8" title="1">{
                return "", errors.New(common.ERR_STRING_NOT_FOUND)
        }</span>
        <span class="cov8" title="1">startInd, err := strconv.ParseInt(start, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.New("ERR invalid start index")
        }</span>
        <span class="cov8" title="1">endInd, err := strconv.ParseInt(end, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.New("ERR invalid end index")
        }</span>
        <span class="cov8" title="1">length := int64(len(val))
        if length == 0 </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">startInd = (startInd%length + length) % length
        endInd = (endInd%length + length) % length
        if startInd &gt; endInd </span><span class="cov8" title="1">{
                return "", errors.New("ERR start index greater than end index")
        }</span>
        <span class="cov8" title="1">return val[startInd : endInd+1], nil</span>
}

func GetSet(key, value string) (string, error) <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        val, ok := store.Get[string, string](key)
        if !ok </span><span class="cov8" title="1">{
                return "", errors.New(common.ERR_STRING_NOT_FOUND)
        }</span>
        <span class="cov8" title="1">store.Set(key, value)
        return val, nil</span>
}

func Incr(key string) error <span class="cov8" title="1">{
        return IncrBy(key, "1")
}</span>

func IncrBy(key, value string) error <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        incrVal, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("ERR invalid increment value")
        }</span>
        <span class="cov8" title="1">val, ok := store.Get[string, string](key)
        if !ok </span><span class="cov8" title="1">{
                store.Set(key, value)
                return nil
        }</span>
        <span class="cov8" title="1">intVal, err := strconv.ParseInt(val, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("ERR value is not an integer or out of range")
        }</span>
        <span class="cov8" title="1">store.Set(key, fmt.Sprint(intVal+incrVal))
        return nil</span>
}

func IncrByFloat(key, value string) error <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        incrVal, err := strconv.ParseFloat(value, 64)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("ERR invalid increment value")
        }</span>
        <span class="cov8" title="1">val, ok := store.Get[string, string](key)
        if !ok </span><span class="cov8" title="1">{
                store.Set(key, value)
                return nil
        }</span>
        <span class="cov8" title="1">floatVal, err := strconv.ParseFloat(val, 64)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("ERR value is not a float or out of range")
        }</span>
        <span class="cov8" title="1">store.Set(key, fmt.Sprint(floatVal+incrVal))
        return nil</span>
}

func Set(key, value string) <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        store.Set(key, value)
}</span>

func Lcs(key1 string, key2 string, commands []string) (string, error) <span class="cov8" title="1">{
        store.GlobalLock.RLock()
        val1, ok1 := store.Get[string, string](key1)
        val2, ok2 := store.Get[string, string](key2)
        store.GlobalLock.RUnlock()

        if !ok1 || !ok2 </span><span class="cov8" title="1">{
                return "", errors.New(common.ERR_STRING_NOT_FOUND)
        }</span>

        <span class="cov8" title="1">lcs, lcsLen := findLcs(val1, val2)
        if len(commands) == 1 &amp;&amp; strings.ToUpper(commands[0]) == "LEN" </span><span class="cov8" title="1">{
                return fmt.Sprint(lcsLen), nil
        }</span>
        <span class="cov8" title="1">return lcs, nil</span>
}

func MGet(keys *[]string) *[]string <span class="cov8" title="1">{
        store.GlobalLock.RLock()
        defer store.GlobalLock.RUnlock()
        values := make([]string, len(*keys))
        for i, key := range *keys </span><span class="cov8" title="1">{
                val, ok := store.Get[string, string](key)
                if !ok </span><span class="cov8" title="1">{
                        values[i] = ""
                }</span> else<span class="cov8" title="1"> {
                        values[i] = val
                }</span>
        }
        <span class="cov8" title="1">return &amp;values</span>
}

func MSet(kvPairs *map[string]string) <span class="cov8" title="1">{
        store.GlobalLock.Lock()
        defer store.GlobalLock.Unlock()
        for key, val := range *kvPairs </span><span class="cov8" title="1">{
                store.Set(key, val)
        }</span>
}

/* PRIVATE FUNCTIONS */

func findLcs(str1, str2 string) (string, int) <span class="cov8" title="1">{
        m, n := len(str1), len(str2)
        if m &lt; n </span><span class="cov8" title="1">{
                str1, str2 = str2, str1
                m, n = n, m
        }</span>

        <span class="cov8" title="1">prev := make([]int, n+1)
        curr := make([]int, n+1)

        for i := range m </span><span class="cov8" title="1">{
                for j := range n </span><span class="cov8" title="1">{
                        if str1[i] == str2[j] </span><span class="cov8" title="1">{
                                curr[j+1] = prev[j] + 1
                        }</span> else<span class="cov8" title="1"> {
                                curr[j+1] = max(curr[j], prev[j+1])
                        }</span>
                }
                <span class="cov8" title="1">prev, curr = curr, prev</span>
        }

        <span class="cov8" title="1">lcsLen := prev[n]
        lcs := make([]byte, lcsLen)
        i, j, k := m, n, lcsLen

        for i &gt; 0 &amp;&amp; j &gt; 0 </span><span class="cov8" title="1">{
                if str1[i-1] == str2[j-1] </span><span class="cov8" title="1">{
                        k--
                        lcs[k] = str1[i-1]
                        i--
                        j--
                }</span> else<span class="cov8" title="1"> if prev[j] &gt; prev[j-1] </span><span class="cov8" title="1">{
                        i--
                }</span> else<span class="cov8" title="1"> {
                        j--
                }</span>
        }
        <span class="cov8" title="1">return string(lcs), lcsLen</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package main

import (
        "github.com/divy-sh/animus/cmd/animus"
)

func main() <span class="cov0" title="0">{
        animus.Handle()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
